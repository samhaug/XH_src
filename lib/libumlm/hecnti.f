      SUBROUTINE HECNTI(GRID,IGRID,IKY,IKX,NSHD,Z1,Z2,XB1,XB2,YB1,YB2
     1      ,IFCLIP,CX,CY,INCC,NPTS,IFMAP,MAPFUN
     1      ,XS,YS,INC,IXMAX,IS,IND,ILEV,ISMAX,WK,NWK)
      EXTERNAL MAPFUN
      DIMENSION XS(INC,IXMAX),YS(INC,IXMAX),IND(ISMAX),ILEV(ISMAX)
      DIMENSION INDDUM(2),WK(NWK),CX(INCC,IXMAX),CY(INCC,IXMAX)
      EQUIVALENCE (IPWK,RIPWK)
      EQUIVALENCE (ITEMP,TEMP)
      COMMON /MESH/ NX,NX1,NX2,NX3,NY,NY1,NY2,NY3
      COMMON /CTRING/ NPAUSE,ISIZE,LABEL,XDUM,YDUM
      DIMENSION JCON(2000)
      DIMENSION CON(3),GRID(IGRID,1)
      common/hecwkconfig/mxbdyc,mxnbdy,mxjoicwk,mxcntrs,mxclpwk
      data mxbdyc/50/,mxnbdy/1000/,mxjoicwk/4000/,mxcntrs/500/
     1    ,mxclpwk/500/
      write(6,*) 'entering hecnti'
      iadsclpwk=2*mxcntrs
      iadsjoicwk=max(4*mxnbdy,iadscpwk+mxclpwk)
      iadsind=iadsjoicwk+mxjoicwk
      iadsilev=iadsind+mxcntrs
      iadscnt=iadsilev+mxcntrs
      if(iadscnt.ge.nwk) stop 'hecnti: insufficient space'
      IF(IFCLIP.NE.0) THEN
      if(5*mxbdyc.ge.nwk) stop 'hecnti: insufficient space for cuts'
      DO I=1,IKX
        II=1+MOD(I+IKX/2,IKX)
        XREF=XB1+(XB2-XB1)*FLOAT(II-1)/FLOAT(IKX-1)
        DO J=1,IKY
          JJ=1+MOD(J+IKY/2,IKY)
          YREF=YB1+(YB2-YB1)*FLOAT(JJ-1)/FLOAT(IKY-1)
          XREF1=XREF
          YREF1=YREF
          IF(IFMAP.NE.0) CALL MAPFUN(XREF1,YREF1)
          CALL CUTS(CX,CY,INCC,NPTS,XREF1,YREF1
     1     ,XREF1+1,YREF1+1,WK(1),WK(mxbdyc+1),1,WK(2*mxbdyc+1),mxbdyc
     1     ,NC1,NC2,NC3,WK(3*mxbdyc+1),WK(3*mxbdyc+1),2*mxbdyc)
        IF(MOD(NC1+NC2+NC3,2).NE.0) PAUSE 'HECNTI: BOUNDARY NOT CLOSED'
        IF(MOD(NC1,2).EQ.1) GOTO 44
        ENDDO
      ENDDO
      PAUSE 'HECNTI: REFERENCE POINT NOT FOUND'
      ELSE
      JJ=IKY/2
      II=IKX/2
      XREF=XB1+(XB2-XB1)*FLOAT(II-1)/FLOAT(IKX-1)
      YREF=YB1+(YB2-YB1)*FLOAT(JJ-1)/FLOAT(IKY-1)
      ENDIF
   44 RCLL=1.+FLOAT(NSHD)*(GRID(JJ,II)-Z1)/(Z2-Z1)


      IF(RCLL.GE.0) THEN
        ICLL=IFIX(RCLL)
      ELSE
        ICLL=-1+IFIX(RCLL)
      ENDIF
      ICLL=MAX0(0,MIN0(NSHD+1,ICLL))
      INX=IKY+2
      INY=IKX+2
      NSWAP=(IKY+1)/2
      DO 13 I=1,NSWAP
      II1=IKY+2-I
      DO 13 J=1,IKX
      TEMP=0.
      IF(II1.LE.IKY) TEMP=GRID(II1,J)
      GRID(II1,J)=GRID(I,J)
      GRID(I,J)=TEMP
   13 CONTINUE
      DO 14 J=1,IKX
      JJ1=1+IKX-J
      JJ2=JJ1+1
      DO 14 I=2,IKY+1
   14 GRID(I,JJ2)=GRID(I,JJ1)
      ICON = 500
      NDEV=0
      NOVERR=NSHD
      SO=Z1
      DELS=(Z2-Z1)/FLOAT(NSHD)
      NPAUSE=0
      ISIZE=3
      LABEL=0
C
      NX1=INX-2
      NY1=INY-2
      NX2 = NX1 + 1
      NX3 = NX2 + 1
      NX  = NX1 - 1
      NY2 = NY1 + 1
      NY3 = NY2 + 1
      NY  = NY1 - 1
C
C     Enter here to contour
C
      CON(2) = DELS
      CON(1) = SO
C
C    Mesh point in the range 2 < X < NX2, 2 < y < NY2 are plotted
C

      CALL CNTORGI(GRID,CON,JCON,ICON,NOVERR,2,NX2,IGRID
     1      ,2,NY2,NY3
     1      ,WK(iadscnt+1),WK(iadscnt+2),2,(NWK-iadscnt)/2
     1     ,ISWK,WK(iadsind+1),WK(iadsilev+1),mxcntrs)
      RIPWK=WK(iadsind+ISWK+1)
      IPWK=IPWK-1
      CMX=(XB2-XB1)/FLOAT(IKX-1)
      CMY=(YB2-YB1)/FLOAT(IKY-1)
      K=iadscnt
      DO I=1,IPWK
        K=K+1
        WK(K)=XB1+CMX*WK(K)
        K=K+1
        WK(K)=YB2-CMY*WK(K)
      ENDDO

      IF(IFCLIP.EQ.0) THEN
        CALL DRAWCI(0.,0.,0,1
     1        ,WK(1),WK(2),2,2*mxnbdy,ISBDY,INDDUM,2)
        DO I=1,IKX
        CALL DRAWCI(FLOAT(I-1),0.,1,0
     1        ,WK(1),WK(2),2,2*mxnbdy,ISBDY,INDDUM,2)
        ENDDO
        DO I=1,IKY
        CALL DRAWCI(FLOAT(IKX-1),FLOAT(I-1),1,0
     1        ,WK(1),WK(2),2,2*mxnbdy,ISBDY,INDDUM,2)
        ENDDO
        DO I=1,IKX
        CALL DRAWCI(FLOAT(IKX-I),FLOAT(IKY-1),1,0
     1        ,WK(1),WK(2),2,2*mxnbdy,ISBDY,INDDUM,2)
        ENDDO
        DO I=1,IKY
        CALL DRAWCI(0.,FLOAT(IKY-I),1,0
     1        ,WK(1),WK(2),2,2*mxnbdy,ISBDY,INDDUM,2)
        ENDDO

        K=0
        DO I=1,INDDUM(ISBDY+1)-1
          K=K+1
          WK(K)=XB1+CMX*WK(K)
          K=K+1
          WK(K)=YB2-CMY*WK(K)
        ENDDO
        write(6,*) 'hecnti: joicnt'
        CALL JOICNT(WK(1),WK(2),2,INDDUM(2)-1
     1     ,WK(iadscnt+1),WK(iadscnt+2),2,ISWK
     1     ,WK(iadsind+1),WK(iadsilev+1)
     1     ,XS,YS,INC,IXMAX,IS,IND,ILEV,ISMAX
     1     ,ICLL,XREF,YREF
     1     ,WK(iadsjoicwk+1),WK(iadsjoicwk+1),mxjoicwk)
        write(6,*) 'hecnti: joicnt thru'
        IF(IFMAP.NE.0) THEN
          DO I=1,IND(IS+1)-1
            CALL MAPFUN(XS(1,I),YS(1,I))
          ENDDO
        ENDIF
      ELSE
      IA1=iadscnt+2*IPWK+1
      XXR=XREF
      YYR=YREF
      IF(IFMAP.NE.0) THEN
        DO I=1,IPWK
          II=iadscnt+2*I-1
          CALL MAPFUN(WK(II),WK(II+1))
        ENDDO
      CALL MAPFUN(XXR,YYR)
      ENDIF
      CALL CLPSEG(CX,CY,INCC,NPTS,WK(iadscnt+1),WK(iadscnt+2),2
     1   ,ISWK,WK(iadsind+1),WK(iadsilev+1)
     1   ,WK(IA1),WK(IA1+1),2,(NWK-IA1+1)/2
     1   ,ISSWK,WK(1),WK(mxcntrs+1),mxcntrs
     1   ,WK(iadsclpwk+1),mxclpwk,0)

        CALL JOICNT(CX,CY,INCC,NPTS,WK(IA1),WK(IA1+1),2,ISSWK
c     1     ,WK(1),WK(251)
     1     ,WK(1),WK(mxcntrs+1)
     1     ,XS,YS,INC,IXMAX,IS,IND,ILEV,ISMAX
     1     ,ICLL,XXR,YYR
     1     ,WK(iadsjoicwk+1),WK(iadsjoicwk+1),mxjoicwk)

      ENDIF

      RETURN
      END

      SUBROUTINE CNTORGI(WORK,CON,JCON,ICON,NOVERR,M1,M2,M3
     1      ,N1,N2,N3
     1      ,XS,YS,INC,IXMAX,IS,IND,ILEV,ISMAX)
      DIMENSION XS(INC,IXMAX),YS(INC,IXMAX),IND(ISMAX),ILEV(ISMAX)
      DIMENSION ILIN(1)
      COMMON /MESH/ NX,NX1,NX2,NX3,NY,NY1,NY2,NY3
      COMMON /CTRING/ NPAUSE,ISIZE,LABEL,XDUM,YDUM
      DIMENSION  WORK(M3,N3),CON(3)
      DIMENSION JCON(ICON)
      RNX=FLOAT(M2-M1)
      RNY=FLOAT(N2-N1)
C
C     The next part of the program inserts the buffer points
C     on the matrix WORK (needed for contouring).
C
      DO 16 I = 1,M2
16    WORK(I,1) = I - 2
      DO 7 J = 1,N2
C
C     Correct maximum and minimum contour levels are prepared
C     for the contouring subroutine.
C
 7    WORK(1,J) = J - 2
C     WORK(2,1)=WORK(2,1)-.5
C     WORK(M2,1)=WORK(M2,1)+.5
C     WORK(1,2)=WORK(1,2)-.5
C     WORK(1,N2)=WORK(1,N2)+.5
      XMINEFF=CON(1)
      IF (NOVERR.LT.0) NOVERR=-NOVERR
      XMAX=CON(1)+NOVERR*CON(2)
      IF (XMINEFF.LE.XMAX) GOTO 88
      XMAX=CON(1)
      XMINEFF=CON(1)+NOVERR*CON(2)
   88 NOVERR=NOVERR+1
C
C     Rows are plotted vertically!
C
      CALL PECNTGI(WORK,M2,N2,M3,XMINEFF,XMAX,NOVERR,JCON,0,0
     1      ,XS,YS,INC,IXMAX,IS,IND,ILEV,ISMAX)
C     WRITE(5,"('FROM PECNTGI IS,IND(IS+1)',2I12)") IS,IND(IS+1)
      RETURN
      END

      SUBROUTINE PECNTGI(ARRAY,MDIM,NDIM,IDIMA,LOCNTR,HICNTR
     1      ,NCNTR,WKAREA,EXSC,EXLF
     1      ,XS,YS,INC,IXMAX,IS,IND,ILEV,ISMAX)
      DIMENSION XS(INC,IXMAX),YS(INC,IXMAX),IND(ISMAX),ILEV(ISMAX)
C
C ********  THE SLAC UNIFIED GRAPHICS SYSTEM (VAX-11 VERSION)  ********
C *                      CONTOUR PLOT SUBROUTINE                      *
C *                                                                   *
C *                                                                   *
C *  THE CALLING SEQUENCE IS:                                         *
C *  ARRAY IS A RECTANGULAR FLOATING POINT ARRAY OF DIMENSION MDIM    *
C *  AND NDIM; MDIM AND NDIM ARE FIXED POINT; LOCNTR AND HICNTR ARE   *
C *  FLOATING POINT; NCTR IS FIXED POINT; WKAREA IS A FIXED POINT     *
C *  ARRAY OF APPROXIMATE DIMENSION MDIM*NDIM/7;         *
C *                                                                   *
C *                          ROBERT C. BEACH                          *
C *                    COMPUTATION RESEARCH GROUP                     *
C *                STANFORD LINEAR ACCELERATOR CENTER                 *
C *                                                                   *
C *********************************************************************
C
      INTEGER       MDIM,NDIM
      INTEGER       LINES(4)
      REAL          ARRAY(IDIMA,1)
      REAL          LOCNTR,HICNTR
      INTEGER       NCNTR
      INTEGER*4     WKAREA(1)
      REAL*4        EXXR,EXXL,EXXV,EXYV
      INTEGER*2     EXSC,EXLF
      INTEGER       NCNT,ICNT,MCNT,IROW,ICOL,ISID
      REAL          ZCNT
      REAL          XPNT,YPNT,TPNT,XLBL,YLBL
      INTEGER       JROW,JCOL,JSID
      INTEGER       KROW,KCOL,KSID
      INTEGER       BBIT,BDFG,INFG,MKFG
      REAL          IVR1,IVR2,DVR1,DVR2
      REAL          XSAV,YSAV
      INTEGER*4     PWRS(31)
      INTEGER       XMNB,XMNW,XMNO,XMWD,XMLP,XMUP,XMP0,XMP1
      INTEGER       IRET,JRET,KRET
C
      INTEGER       INT1,INT2
C
      COMMON /PLOTC/ L
      COMMON /CTRING/ NPAUSE,ISIZE,LABEL,EXINC,IFROT
      DATA          PWRS/
     X            1,          2,          4,          8,
     X           16,         32,         64,        128,
     X          256,        512,       1024,       2048,
     X         4096,       8192,      16384,      32768,
     X        65536,     131072,     262144,     524288,
     X      1048576,    2097152,    4194304,    8388608,
     X     16777216,   33554432,   67108864,  134217728,
     X    268435456,  536870912, 1073741824/
C     DATA          LINES/     0,   334,  3336,    34/
      IFINIT=1
      IS=0
      EXXR=-1.0
      EXXL=-1.0
      EXXV=-1.0
      EXYV=1.0
      IF((NDIM.LT.3).OR.(MDIM.LT.3)) GOTO 301
C  COMPUTE THE CONTOUR COUNT.
      KDIM = ((MDIM-2)*(NDIM-1)+NDIM+13)/15
      INT1=MAX0(NCNTR,2)
      NCNT=INT1+(INT1-1)*EXSC
C
C  LOOP FOR EACH CONTOUR.
      DO 112 IICNT=1,NCNT
      ICNT=IICNT
C     WRITE(5,"('LOOP IN PECNTGI: IS=',I12)") IS
C       L=LINES(MOD(ICNT,4)+1)
C       L=LINES(MOD(ICNT-1,KLIN)+1)
        L=0
        ZCNT=LOCNTR+FLOAT(ICNT-1)*(HICNTR-LOCNTR)/FLOAT(NCNT-1)
      IF (NPAUSE .NE. 0) PAUSE 'CHANGE PEN'
        MCNT=MOD(ICNT-1,EXSC+1)
C  GENERATE LABEL IF NECESSARY.
C  CLEAR SEGMENT BIT MAP.
        DO 101 INT1=1,KDIM
          WKAREA(INT1)=0
  101   CONTINUE
C  SET FLAG TO INDICATE BOUNDARYS BEING PROCESSED.
        BDFG=1
C  PROCESS LOWER AND UPPER BOUNDARY.
        DO 104 IICOL=3,NDIM
        ICOL=IICOL
          IROW=3
          ISID=1
          IRET=1
C         GO TO 401
      CALL SUB401(JROW,IROW,JCOL,ICOL,JSID,ISID
     1 ,MKFG,JRET,INFG,BBIT,NDIM,MDIM
     1 ,DVR1,ARRAY,DVR2,XPNT,YPNT,IVR1,IVR2,ZCNT,TPNT,IDIMA
     1 ,BDFG,EXLF,MCNT,LABEL,XLBL,YLBL,EXINC,ANGLE,ISIZE
     1 ,L,IFINIT,XS,YS,INC,IXMAX,IS,IND,ISMAX,ILEV
     1 ,ICNT,XSAV,YSAV,KROW,KCOL,KSID,XMNB,XMNW,XMNO,XMP0,XMWD
     1 ,XMUP,XMLP,XMP1,WKAREA)
C     WRITE(5,"('102 IS=',I10)") IS
  102     IROW=MDIM
          ISID=3
          IRET=2
C         GO TO 401
      CALL SUB401(JROW,IROW,JCOL,ICOL,JSID,ISID
     1 ,MKFG,JRET,INFG,BBIT,NDIM,MDIM
     1 ,DVR1,ARRAY,DVR2,XPNT,YPNT,IVR1,IVR2,ZCNT,TPNT,IDIMA
     1 ,BDFG,EXLF,MCNT,LABEL,XLBL,YLBL,EXINC,ANGLE,ISIZE
     1 ,L,IFINIT,XS,YS,INC,IXMAX,IS,IND,ISMAX,ILEV
     1 ,ICNT,XSAV,YSAV,KROW,KCOL,KSID,XMNB,XMNW,XMNO,XMP0,XMWD
     1 ,XMUP,XMLP,XMP1,WKAREA)
C     WRITE(5,"('103 IS=',I10)") IS
  103     CONTINUE
  104   CONTINUE
C  PROCESS LEFT AND RIGHT BOUNDARY.
        DO 107 IIROW=3,MDIM
          IROW=IIROW
          ICOL=3
          ISID=0
          IRET=3
C         GO TO 401
      CALL SUB401(JROW,IROW,JCOL,ICOL,JSID,ISID
     1 ,MKFG,JRET,INFG,BBIT,NDIM,MDIM
     1 ,DVR1,ARRAY,DVR2,XPNT,YPNT,IVR1,IVR2,ZCNT,TPNT,IDIMA
     1 ,BDFG,EXLF,MCNT,LABEL,XLBL,YLBL,EXINC,ANGLE,ISIZE
     1 ,L,IFINIT,XS,YS,INC,IXMAX,IS,IND,ISMAX,ILEV
     1 ,ICNT,XSAV,YSAV,KROW,KCOL,KSID,XMNB,XMNW,XMNO,XMP0,XMWD
     1 ,XMUP,XMLP,XMP1,WKAREA)
C     WRITE(5,"('105 IS=',I10)") IS
  105     ICOL=NDIM
          ISID=2
          IRET=4
C         GO TO 401
      CALL SUB401(JROW,IROW,JCOL,ICOL,JSID,ISID
     1 ,MKFG,JRET,INFG,BBIT,NDIM,MDIM
     1 ,DVR1,ARRAY,DVR2,XPNT,YPNT,IVR1,IVR2,ZCNT,TPNT,IDIMA
     1 ,BDFG,EXLF,MCNT,LABEL,XLBL,YLBL,EXINC,ANGLE,ISIZE
     1 ,L,IFINIT,XS,YS,INC,IXMAX,IS,IND,ISMAX,ILEV
     1 ,ICNT,XSAV,YSAV,KROW,KCOL,KSID,XMNB,XMNW,XMNO,XMP0,XMWD
     1 ,XMUP,XMLP,XMP1,WKAREA)
C     WRITE(5,"('106 IS=',I10)") IS
  106     CONTINUE
  107   CONTINUE
C  SET FLAG TO INDICATE BOUNDARYS NOT BEING PROCESSED.
        BDFG=0
C  PROCESS INTERIOR SIDES OF SURFACE PATCHES.
        IF (NDIM.LT.4) GO TO 111
        DO 110 IICOL=4,NDIM
        ICOL=IICOL
          DO 109 IIROW=3,MDIM
            IROW=IIROW
            ISID=0
            IRET=5
C           GO TO 401
      CALL SUB401(JROW,IROW,JCOL,ICOL,JSID,ISID
     1 ,MKFG,JRET,INFG,BBIT,NDIM,MDIM
     1 ,DVR1,ARRAY,DVR2,XPNT,YPNT,IVR1,IVR2,ZCNT,TPNT,IDIMA
     1 ,BDFG,EXLF,MCNT,LABEL,XLBL,YLBL,EXINC,ANGLE,ISIZE
     1 ,L,IFINIT,XS,YS,INC,IXMAX,IS,IND,ISMAX,ILEV
     1 ,ICNT,XSAV,YSAV,KROW,KCOL,KSID,XMNB,XMNW,XMNO,XMP0,XMWD
     1 ,XMUP,XMLP,XMP1,WKAREA)
C     WRITE(5,"('108 IS=',I10)") IS
  108       CONTINUE
  109     CONTINUE
  110   CONTINUE
  111   CONTINUE
  112 CONTINUE
      GOTO 201
 301  WRITE(6,302) NDIM,MDIM
 302  FORMAT(1X,'NO CONTOURING: NDIM = ',I3,' MDIM = ',I3)
 201  RETURN
      END

      SUBROUTINE SUB401(JROW,IROW,JCOL,ICOL,JSID,ISID
     1 ,MKFG,JRET,INFG,BBIT,NDIM,MDIM
     1 ,DVR1,ARRAY,DVR2,XPNT,YPNT,IVR1,IVR2,ZCNT,TPNT,IDIMA
     1 ,BDFG,EXLF,MCNT,LABEL,XLBL,YLBL,EXINC,ANGLE,ISIZE
     1 ,L,IFINIT,XS,YS,INC,IXMAX,IS,IND,ISMAX,ILEV
     1 ,ICNT,XSAV,YSAV,KROW,KCOL,KSID,XMNB,XMNW,XMNO,XMP0,XMWD
     1 ,XMUP,XMLP,XMP1,WKAREA)
      DIMENSION XS(INC,IXMAX),YS(INC,IXMAX),IND(ISMAX),ILEV(ISMAX)
C   $$
C     CALL SUB501(MKFG,JSID,DVR1,ARRAY,JROW,JCOL,DVR2,XPNT,YPNT
C    1  ,IVR1,IVR2,ZCNT,TPNT,INFG,IDIMA)
C     CALL SUB601(BDFG,EXLF,MCNT,LABEL,XLBL,XPNT
C    1  ,YLBL,YPNT,JSID,EXINC,ANGLE,ISIZE,ZCNT)
C     CALL SUB701(BBIT,L,XPNT,YPNT,IFINIT
C    1 ,XS,YS,INC,IXMAX,IS,IND,ISMAX,ILEV
C    1 ,ICNT,XSAV,YSAV)
C     CALL SUB801(1,MKFG,KROW,JROW,KCOL,JCOL,KSID
C    1 ,JSID,XMNB,NDIM,XMNW,XMNO,XMP0,XMWD,XMUP,XMLP,XMP1
C    1 ,WKAREA)
C   $$
C  INTERNAL ROUTINE TO PROCESS THE ISID-TH SIDE OF THE
C  (IROW,ICOL)-TH SURFACE PATCH.  IF THE SIDE HAS NOT BEEN
C  CHECKED BEFORE, THEN THE CONTOUR IS EXAMINED TO SEE IF IT
C  CROSSES THE SIDE.  IF IT DOES NOT, THE SIDE IS MARKED AS
C  HAVING BEEN CHECKED.  IF THE CONTOUR CROSSES THE SIDE, THE
C  CONTOUR IS FOLLOWED UNTIL IT IS COMPLETE AND ALL AFFECTED
C  SIDES ARE MARKED AS HAVING BEEN CHECKED.
      REAL          ARRAY(IDIMA,1)
      REAL          LOCNTR,HICNTR
      INTEGER*4     WKAREA(1)
      INTEGER*2     EXSC,EXLF
      INTEGER       BBIT,BDFG,INFG,MKFG
      REAL          IVR1,IVR2,DVR1,DVR2
      REAL          XSAV,YSAV
      INTEGER       XMNB,XMNW,XMNO,XMWD,XMLP,XMUP,XMP0,XMP1
  401 JROW=IROW
      JCOL=ICOL
      JSID=ISID
C  DO ANY CONTOURS BEGIN AT THIS SIDE?
      KRET=1
C     GO TO 851
      CALL SUB801(1,MKFG,KROW,JROW,KCOL,JCOL,KSID
     1 ,JSID,XMNB,NDIM,XMNW,XMNO,XMP0,XMWD,XMUP,XMLP,XMP1
     1 ,WKAREA)
  402 IF (MKFG.EQ.1) GO TO 471
      JRET=1
C     GO TO 501
      CALL SUB501(MKFG,JSID,DVR1,ARRAY,JROW,JCOL,DVR2,XPNT,YPNT
     1  ,IVR1,IVR2,ZCNT,TPNT,INFG,IDIMA)
  403 IF (INFG.EQ.0) GO TO 463
C  START DRAWING THE CONTOUR CURVE.
      JRET=1
C     GO TO 601
      CALL SUB601(BDFG,EXLF,MCNT,LABEL,XLBL,XPNT
     1  ,YLBL,YPNT,JSID,EXINC,ANGLE,ISIZE,ZCNT)
  404 BBIT=2
      JRET=1
C     GO TO 701
      CALL SUB701(BBIT,L,XPNT,YPNT,IFINIT
     1 ,XS,YS,INC,IXMAX,IS,IND,ISMAX,ILEV
     1 ,ICNT,XSAV,YSAV)
  405 BBIT=0
C  FIND THE OTHER SIDE OF THE PATCH.
  411 JSID=MOD(JSID+2,4)
      KRET=2
C     GO TO 851
      CALL SUB801(1,MKFG,KROW,JROW,KCOL,JCOL,KSID
     1 ,JSID,XMNB,NDIM,XMNW,XMNO,XMP0,XMWD,XMUP,XMLP,XMP1
     1 ,WKAREA)
  412 IF (MKFG.EQ.1) GO TO 414
      JRET=2
C     GO TO 501
      CALL SUB501(MKFG,JSID,DVR1,ARRAY,JROW,JCOL,DVR2,XPNT,YPNT
     1  ,IVR1,IVR2,ZCNT,TPNT,INFG,IDIMA)
  413 IF (INFG.NE.0) GO TO 421
      KRET=3
C     GO TO 801
      CALL SUB801(0,MKFG,KROW,JROW,KCOL,JCOL,KSID
     1 ,JSID,XMNB,NDIM,XMNW,XMNO,XMP0,XMWD,XMUP,XMLP,XMP1
     1 ,WKAREA)
  414 JSID=MOD(JSID+1,4)
      KRET=4
C     GO TO 851
      CALL SUB801(1,MKFG,KROW,JROW,KCOL,JCOL,KSID
     1 ,JSID,XMNB,NDIM,XMNW,XMNO,XMP0,XMWD,XMUP,XMLP,XMP1
     1 ,WKAREA)
  415 IF (MKFG.EQ.1) GO TO 417
      JRET=3
C     GO TO 501
      CALL SUB501(MKFG,JSID,DVR1,ARRAY,JROW,JCOL,DVR2,XPNT,YPNT
     1  ,IVR1,IVR2,ZCNT,TPNT,INFG,IDIMA)
  416 IF (INFG.NE.0) GO TO 421
      KRET=5
C     GO TO 801
      CALL SUB801(0,MKFG,KROW,JROW,KCOL,JCOL,KSID
     1 ,JSID,XMNB,NDIM,XMNW,XMNO,XMP0,XMWD,XMUP,XMLP,XMP1
     1 ,WKAREA)
  417 JSID=MOD(JSID+2,4)
      KRET=6
C     GO TO 851
      CALL SUB801(1,MKFG,KROW,JROW,KCOL,JCOL,KSID
     1 ,JSID,XMNB,NDIM,XMNW,XMNO,XMP0,XMWD,XMUP,XMLP,XMP1
     1 ,WKAREA)
 418  JRET=4
C     GO TO 501
      CALL SUB501(MKFG,JSID,DVR1,ARRAY,JROW,JCOL,DVR2,XPNT,YPNT
     1  ,IVR1,IVR2,ZCNT,TPNT,INFG,IDIMA)
 419  CONTINUE
C  DRAW CURRENT PART OF THE CONTOUR.
  421 JRET=2
C     GO TO 701
      CALL SUB701(BBIT,L,XPNT,YPNT,IFINIT
     1 ,XS,YS,INC,IXMAX,IS,IND,ISMAX,ILEV
     1 ,ICNT,XSAV,YSAV)
C  MARK THE LINE PROCESSED.
  431 KRET=7
C     GO TO 801
      CALL SUB801(0,MKFG,KROW,JROW,KCOL,JCOL,KSID
     1 ,JSID,XMNB,NDIM,XMNW,XMNO,XMP0,XMWD,XMUP,XMLP,XMP1
     1 ,WKAREA)
C  FIND THE ADJACENT SURFACE PATCH.
  441 IF (JSID.EQ.3) GO TO 444
      IF (JSID.EQ.2) GO TO 443
      IF (JSID.EQ.1) GO TO 442
      IF (JCOL.LE.3) GO TO 461
      JCOL=JCOL-1
      JSID=2
      GO TO 451
  442 IF (JROW.LE.3) GO TO 461
      JROW=JROW-1
      JSID=3
      GO TO 451
  443 IF (JCOL.GE.NDIM) GO TO 461
      JCOL=JCOL+1
      JSID=0
      GO TO 451
  444 IF (JROW.GE.MDIM) GO TO 461
      JROW=JROW+1
      JSID=1
C  CHECK FOR CLOSURE OF THE CONTOUR LINE.
  451 IF ((JROW.EQ.IROW).AND.(JCOL.EQ.ICOL).AND.(JSID.EQ.ISID))
     X  GO TO 471
      GO TO 411
C  FINISH AN OPEN CURVE.
  461 JRET=2
C     GO TO 601
      CALL SUB601(BDFG,EXLF,MCNT,LABEL,XLBL,XPNT
     1  ,YLBL,YPNT,JSID,EXINC,ANGLE,ISIZE,ZCNT)
  462 JROW=IROW
      JCOL=ICOL
      JSID=ISID
  463 KRET=8
C     GO TO 801
      CALL SUB801(0,MKFG,KROW,JROW,KCOL,JCOL,KSID
     1 ,JSID,XMNB,NDIM,XMNW,XMNO,XMP0,XMWD,XMUP,XMLP,XMP1
     1 ,WKAREA)
C  THE CONTOUR LINE IS NOW COMPLETE.
C 471 GO TO (102,103,105,106,108),IRET
  471 RETURN
      END

      SUBROUTINE SUB501(MKFG,JSID,DVR1,ARRAY,JROW,JCOL,DVR2,XPNT,YPNT
     1  ,IVR1,IVR2,ZCNT,TPNT,INFG,IDIMA)
      REAL          ARRAY(IDIMA,1)
      REAL          IVR1,IVR2,DVR1,DVR2
C
C  INTERNAL ROUTINE TO DETERMINE IF THE (JROW,JCOL,JSID)-TH
C  SIDE IS INTERSECTED BY THE CURRENT CONTOUR LINE.  IF THE
C  ANSWER IS YES, INFG IS SET TO ONE AND THE COORDINATES
C  OF THE INTERSECTION ARE SAVED IN (XPNT,YPNT).
C  FIRST, OBTAIN THE INDEPENDENT AND DEPENDENT VARIABLES.
 501  CONTINUE
      IF (MKFG.NE.0) GO TO 510
      IF (JSID.EQ.3) GO TO 505
      IF (JSID.EQ.2) GO TO 503
      IF (JSID.EQ.1) GO TO 502
      DVR1=ARRAY(JROW-1,JCOL-1)
      DVR2=ARRAY(JROW,JCOL-1)
      XPNT=ARRAY(1,JCOL-1)
      GO TO 504
  502 DVR1=ARRAY(JROW-1,JCOL-1)
      DVR2=ARRAY(JROW-1,JCOL)
      YPNT=ARRAY(JROW-1,1)
      GO TO 506
  503 DVR1=ARRAY(JROW-1,JCOL)
      DVR2=ARRAY(JROW,JCOL)
      XPNT=ARRAY(1,JCOL)
  504 IVR1=ARRAY(JROW-1,1)
      IVR2=ARRAY(JROW,1)
      GO TO 507
  505 DVR1=ARRAY(JROW,JCOL-1)
      DVR2=ARRAY(JROW,JCOL)
      YPNT=ARRAY(JROW,1)
  506 IVR1=ARRAY(1,JCOL-1)
      IVR2=ARRAY(1,JCOL)
C  CHECK FOR AN INTERSECTION.
 507  CONTINUE
      IF (((DVR1.LT.ZCNT).AND.(DVR2.LT.ZCNT)).OR.
     X  ((DVR1.GE.ZCNT).AND.(DVR2.GE.ZCNT))) GO TO 510
C  COMPUTE THE OTHER COORDINATE.
      TPNT=IVR1+(ZCNT-DVR1)*(IVR2-IVR1)/(DVR2-DVR1)
      IF (MOD(JSID,2).EQ.0) GO TO 508
      XPNT=TPNT
      GO TO 509
  508 YPNT=TPNT
C  RETURN WITH INTERSECTION.
  509 INFG=1
      GO TO 511
C  RETURN WITHOUT INTERSECTION.
  510 INFG=0
 511  CONTINUE
C     GO TO (403,413,416,419),JRET
      RETURN
      END

      SUBROUTINE SUB601(BDFG,EXLF,MCNT,LABEL,XLBL,XPNT
     1  ,YLBL,YPNT,JSID,EXINC,ANGLE,ISIZE,ZCNT)
      INTEGER       BBIT,BDFG,INFG,MKFG
      INTEGER*2     EXSC,EXLF
C
C  INTERNAL ROUTINE TO LABEL A CONTOUR IF A LABEL IS
C  REQUIRED.  THE LABEL IS POSITIONED AT THE PROPER OFFSET
C  FROM (XPNT,YPNT).
  601 IF ((BDFG.EQ.0).OR.(EXLF.NE.0).OR.(MCNT.NE.0).OR.(LABEL.EQ.0))
     X  GO TO 606
      XLBL=XPNT
      YLBL=YPNT
C  GET THE COORDINATES OF THE LABEL.
      IF (JSID.EQ.3) GO TO 604
      IF (JSID.EQ.2) GO TO 603
      IF (JSID.EQ.1) GO TO 602
      XLBL=XLBL-3.5*EXINC
      ANGLE=0.0
      GO TO 605
  602 YLBL=YLBL-3.5*EXINC
      ANGLE=90.0
      GO TO 605
  603 XLBL=XLBL+0.5*EXINC
      ANGLE=0.0
      GO TO 605
  604 YLBL=YLBL+0.5*EXINC
      ANGLE=90.0
C  PRODUCE THE LABEL.
  605 CALL NUMBERI(XLBL,YLBL,ISIZE,ZCNT,ANGLE,'(F5.0)')
C 606 GO TO (404,462),JRET
  606 RETURN
      END

      SUBROUTINE SUB701(BBIT,L,XPNT,YPNT,IFINIT
     1 ,XS,YS,INC,IXMAX,IS,IND,ISMAX,ILEV
     1 ,ICNT,XSAV,YSAV)
      DIMENSION XS(INC,IXMAX),YS(INC,IXMAX),IND(ISMAX),ILEV(ISMAX)
      INTEGER       BBIT
C  INTERNAL PROCEDURE TO DRAW A LINE TO THE POINT (XPNT,YPNT).
  701 IF (BBIT.EQ.0.AND.L.NE.0) GO TO 703
      ISS=IS
      CALL PLOTI(XPNT,YPNT,BBIT,IFINIT
     1      ,XS,YS,INC,IXMAX,IS,IND,ISMAX)
      IF(IS.NE.0.AND.IS.NE.ISS) ILEV(IS)=ICNT
      GO TO 704
 703  ISS=IS
      CALL PLOTI(XPNT,YPNT,4,IFINIT
     1      ,XS,YS,INC,IXMAX,IS,IND,ISMAX)
      IF(IS.NE.0.AND.IS.NE.ISS) ILEV(IS)=ICNT
 704  XSAV=XPNT
      YSAV=YPNT
C     GO TO (405,431),JRET
      RETURN
      END

      SUBROUTINE SUB801(ISKIP,MKFG,KROW,JROW,KCOL,JCOL,KSID
     1 ,JSID,XMNB,NDIM,XMNW,XMNO,XMP0,XMWD,XMUP,XMLP,XMP1
     1 ,WKAREA)
      INTEGER*4     WKAREA(1)
      INTEGER*4     PWRS(31)
      INTEGER       XMNB,XMNW,XMNO,XMWD,XMLP,XMUP,XMP0,XMP1
      DATA          PWRS/
     X            1,          2,          4,          8,
     X           16,         32,         64,        128,
     X          256,        512,       1024,       2048,
     X         4096,       8192,      16384,      32768,
     X        65536,     131072,     262144,     524288,
     X      1048576,    2097152,    4194304,    8388608,
     X     16777216,   33554432,   67108864,  134217728,
     X    268435456,  536870912, 1073741824/
C
C  801 IS AN INTERNAL ROUTINE TO MARK THE (JROW,JCOL,JSID)-TH
C  LINE AS HAVING BEEN PROCESSED.  851 IS AN INTERNAL ROUTINE
C  TO TEST IF THE (JROW,JCOL,JSID)-TH LINE HAS BEEN MARKED.  IF
C  IT HAS, MKFG IS SET TO ONE.
      IF(ISKIP.NE.0) GOTO 851
  801 MKFG=0
      GO TO 852
  851 MKFG=1
  852 KROW=JROW
      KCOL=JCOL
      KSID=JSID
      IF (KSID.NE.2) GO TO 853
      KSID=0
      KCOL=KCOL+1
      GO TO 854
  853 IF (KSID.NE.3) GO TO 854
      KSID=1
      KROW=KROW+1
  854 XMNB=2*((KROW-3)*(NDIM-1)+(KCOL-3))+KSID
      XMNW=1+XMNB/30
      XMNO=1+MOD(XMNB,30)
      XMP0=PWRS(XMNO)
      XMWD=WKAREA(XMNW)
      IF (MKFG.EQ.0) GO TO 855
      XMUP=XMWD/XMP0
      IF (MOD(XMUP,2).EQ.0) MKFG=0
      GO TO 856
  855 XMP1=PWRS(XMNO+1)
      XMLP=MOD(XMWD,XMP0)
      XMUP=XMWD/XMP1
      WKAREA(XMNW)=XMUP*XMP1+XMP0+XMLP
C 856 GO TO (402,412,414,415,417,418,441,471),KRET
  856 RETURN
      END

      SUBROUTINE PLOTI(X,Y,N,IFINIT
     1      ,XS,YS,INC,IXMAX,IS,IND,ISMAX)
      COMMON /PLOTC/ L
      NN = N + 1
      GOTO (1,2,3,4,5,6),NN
 1    CALL DRAWCI(X,Y,1,IFINIT
     1      ,XS,YS,INC,IXMAX,IS,IND,ISMAX)
      IFINIT=0
      RETURN
 2    CALL DRAWCIR(X,Y,1,IFINIT
     1      ,XS,YS,INC,IXMAX,IS,IND,ISMAX)
      IFINIT=0
      RETURN
 3    CALL DRAWCI(X,Y,0,IFINIT
     1      ,XS,YS,INC,IXMAX,IS,IND,ISMAX)
      IFINIT=0
      RETURN
 4    CALL DRAWCIR(X,Y,0,IFINIT
     1      ,XS,YS,INC,IXMAX,IS,IND,ISMAX)
      IFINIT=0
      RETURN
 5    CALL DASHA(X,Y,1,IFINIT
     1      ,XS,YS,INC,IXMAX,IS,IND,ISMAX)
      IFINIT=0
      RETURN
 6    CALL DRAWCIR(X,Y,1,IFINIT
     1      ,XS,YS,INC,IXMAX,IS,IND,ISMAX)
      IFINIT=0
      RETURN
      END
      
      SUBROUTINE NUMBERI
      RETURN
      END
